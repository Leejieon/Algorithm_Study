## **🔎문제해석**
​
**처음에는 무작정 재귀로 박치기했는데** 

![img](https://user-images.githubusercontent.com/99114456/187181772-abdda1d5-fe36-4587-acfa-ef9e13175eb9.png)

**멸망했다..**
**생각해보면 당연한 건데 나는 처음에 문자열에다가 계속 추가해줬는데 최대의 크기가 10^9라 당연히 메모리 초과가 날 수밖에 없는 것.. 그렇게 해서 다음 접근한 게 글자 수의 규칙을 찾아서 해당 글자 수에 해당하는 글자를 뽑아내려고 했는데 이것도 규칙 찾다가 날밤 샐 거 같아서 포기하고 그냥 분할 정복을 하기로 했다.**

**Moo 게임에는 규칙이 있다.**

## **S(0) = Moo**

## **S(1) = MooMoooMoo**

## **S(2) = MooMoooMooMooooMooMoooMoo**

**위의 식을 보면 알 수 있듯이** 

**S(k)= S(k-1) + M+ o\*(k+2) + S(k-1)이라는 점을 알 수 있다. \[단 k>=1\]**

**S에 대한 3가지 구간이 있다.**

-   **S(k-1)인 구간**
-   **Moo 게임의 규칙인 M+o\*(k+2)**
-   **S(k-1)인 구간**

![image](https://user-images.githubusercontent.com/99114456/187182495-98824d01-5736-4cb8-ae99-dab5a9ff9e8b.png)

**이렇게 3구간으로 나눠져 있다.**

**여기서 만약 내가 찾고자 하는 n번째 글자가 S(2)에 있는 경우 그 글자는 파란색 구간과 초록색 구간에 있어야 하는 것이 당연하다.**

**만약 빨간색 구간에 있다고 생각이 든다면 S(2)가 아닌 S(1)에서 그 글자가 찾아질 것이다.**

**이제 우리는 찾고자 하는 글자가 파란색 구간과 초록색 구간에 있다는 것을 알고 있으니 조건만 정해주면 된다.**

**만약 파란색 구간에 있다면 첫 글자를 제외한 모두가 "o"를 가리킬 것이고, 첫 글자는 "m"을 가르킬 것이다.**

**만약 초록색 구간에 있다면 그 초록색 구간을 다시 분할해서 \[S(0)이 될 때까지)\] 글자를 구하면 된다.**

### **💻예시를 들어서 설명해보겠다.**

#### **만약 23번째 글자를 찾고 싶다고 가정할 때**

**S(0)은 3글자. S(1)은 10글자. S(2)는 25글자** 

**따라서 23번째 글자는 S(2)에 있고, 23은  빨간색 구간\[S(1)\] + 파란색 구간\[2+3\]보다 크기 때문에 초록색 구간인 것을 알 수 있다.**

![image](https://user-images.githubusercontent.com/99114456/187182572-5fcd205e-2020-41d1-aa67-18edcee48f4d.png)

**23번째 글자는 빨간색 부분이다.**

**다시 이 MooMoooMoo를 분할한다.**

![image](https://user-images.githubusercontent.com/99114456/187182618-e15148f1-eb65-4a07-87a5-206b6091d257.png)

**우리가 찾고자 하는 하얀색 M은 또 초록색 구간에 있기에 또 분할을 한다.**

**Moo는 우리가 정한 최소 글자 수\[3\]이기에 여기서 M에 대한 index인 M을 출력하면 된다.**

---

## **✔느낀 점**

-   **분할 정복은 손이 고생해야 한다!**
-   **머리로 하려고 하지 말고 일단 처음부터 규칙을 찾고 손으로 해보는 게 맞을 거 같다.**
-   **이 문제 어려웠다..** 
-   **분할 정복은 확실히 많이 풀어봐야 할 것 같다.**
