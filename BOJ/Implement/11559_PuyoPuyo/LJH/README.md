## **👀문제 해석**

**문제를 읽어보면 중요한 포인트가 3개 정도 있다.**

1.  **우선 연결 여부는 상하좌우 4방향으로만 인정한다.**
    1.  **여기서 상하좌우로 쭉쭉 이동해서 같은색 뿌요들이 4개 이상이라면 그 뿌요들은 없어진다.**
2.  **뿌요들이 없어지면 위에 있는 뿌요들은 중력의 영향을 받아서 아래로 떨어진다.**
3.  **동시에 연쇄가 터지더라도 같은 시간대에 일어나면 연쇄는 한번이라고 처리한다.**

**이러한 3가지 쟁점을 두고 문제에 접근하면 문제 풀기가 용이할 것입니다.**

## **🔎문제 풀이**

#### **1️⃣변수선언**

![img](https://user-images.githubusercontent.com/99114456/209539652-68914625-32d6-4df6-b38d-1975f5f51e61.png)

-   **result는 연쇄 횟수, step과 alph는 bfs를 하는 데 사용되는 변수, flag는 연쇄발생에 대한 여부를 저장**
-   **q는 bfs를 할 때 사용되는 q이고, 2차원 배열에 대한 좌표가 들어감.**
-   **graph는 입력받는 행렬, visit는 방문처리에 대한 배열**
-   **x, y는 방향벡터이고, color는 뿌요의 색깔을 저장하고, p는 연쇄 성공한 2차원 배열 좌표가 들어감.**

#### **2️⃣알고리즘**

-   **반복문을 돌다가 검사를 진행**
    -   **해당 검사는 빈 공간이 아니고, 방문하지 않았어야 함.**
    -   **검사에 통과하면 해당 좌표를 q에 넣고, bfs를 진행**
-   **bfs**
    -   **다른 bfs와 같이 큐가 완전히 빌 때까지 진행한다.**
    -   **좌표와 알파벳을 뽑아주고, pop을 한다.**
        -   **만약 해당 좌표가 이미 방문한 좌표라면 continue 실행**
        -   **아니라면 해당 색깔에 대한 count를 증가시켜 주고, 방문 처리를 해준다.**
    -   **상하좌우로 탐색**
        -   **좌표가 적절하지 않은 좌표라면 continue 실행**
            -   **적절하지 않은 좌표 -> 배열을 넘어가거나, 큐에서 뽑은 알파벳과 다른 경우, 방문한 경우**
        -   **적절한 좌표라면 큐에 넣어줌.**
-   **탐색이 끝난 뒤**
    -   **같은 색깔의 뿌요가 4개 이상이라면 연쇄성공,**  
        **flag \[연쇄여부\] = true로 바꿔주고, color를 다시 0으로 초기화해 줌.**
    -   **같은 색깔의 뿌요가 4개 이하라면 연쇄실패,**  
        **p에는 쓰레기 좌표가 들어갔으므로, 특정 뿌요 색깔 수만큼 p를 지워줌.**
-   **bfs함수가 완전히 끝난 뒤**
    -   **방문배열을 초기화시켜 줌.**
    -   **p에는 연쇄성공한 좌표가 들어있고, 해당 좌표를 빈 공간으로 초기화**
-   **중력적용**
    -   **빈 공간이 아니라면 큐에 해당 알파벳을 넣은 뒤, 큐가 빌 때까지 알파벳을 넣어준다.**
    -   **만약 큐가 비면 전부 다 처리 해줌.**
-   **연쇄 여부**
    -   **flag값이 true라면 연쇄 횟수를**
    -   **flag값이 false라면 연쇄가 더 이상 연쇄가 불가능하므로 종료해 줌.**

## **✔느낀 점**

-   **구현 문제는 정말 알고리즘 선택이 중요한 것 같습니다... 반복된 훈련으로 문제가 요구하는 탁월한 자료구조와 알고리즘을 선택하는 것이 필요하다고 느꼈습니다.**
-   **중력 적용에 대한 코드 짜기가 굉장히 애먹었습니다.**
-   **select\_color 같은 함수를 안 짜고 깔끔하게 짤 수 있었을 거 같은데 너무 복잡하게 짠 것 같아서 부끄럽네요,,**
