## **👀문제 해석**
​
-   **문제가 길고 복잡해보이지만 , 실제로는 단순한 부분들만 생각해 주면 된다.**
-   **회전하려는 톱니바퀴와 맞닿는 부분들의 극이 다르면 회전에 영향을 준다.**
    -   **예를 들어서 2번째 바퀴가 회전할 때 3번째와 2번째가 맞닿는 부분이 다르다면 3번째는 2번째 바퀴의 회전방향과 반대로 회전한다. 만약 맞닿는 부분이 같을 시 2번째 바퀴만 회전한다.**
-   **여기서 주의해야할점은 연쇄작용으로 톱니바퀴가 영향을 서로 준다는 점이다.**
    -   **예를 들어 1번쨰회전 ->2번째 회전, 2번째 회전->3번째 회전, 3번째 회전 -> 4번째 회전에 영향을 줄 수 있다.**
    -   **여기서 생각해야할점은 각각 맞닿는 부분들이 회전하기 전 상태를 비교해야 한다는 점이다.**
    -   **즉 우리는 맞닿는 부분이 다르다고 무작정 회전시킬 것이 아니고 회전의 방향을 정해서 4번째 바퀴까지 검사한 뒤에 회전시켜줘야 한다.**
-   **전부 다 회전하면 각각의 12시 방향을 검사해서 결과를 도출하면 된다.**
​
## **🔎문제 풀이**
​
-   **우선 시계방향과 반시계 방향에 대해서 생각해 보면 `deque`로 구현하면 굉장히 쉽다는 것을 깨달았다.**
    -   **아래 그림을 보면 이해가 쉬울 것!**
​
![img](https://user-images.githubusercontent.com/99114456/212752141-8906b956-5720-4e4b-9fad-127f3c2b2c2b.png)
​
-   **deque를 쓰면 편리하다고 생각한 이유**
    -   **시계방향일 때는 맨뒤의 원소를 빼준뒤 첫 번째 자리로 옮겨주는 것이다.**
        -   **pop\_back() -> push\_front()**
    -   **시계반대방향일 때는 맨 앞의 원소를 빼준 뒤의 맨 뒷자리로 옮겨주는 것이다.**
        -   **pop\_front() -> push\_back()**
    -   **이러한 이유로 앞, 뒤에서 빼서 그대로 맨, 앞으로 이어 붙일 수 있는 `deque`가 적절하다고 판단했다.**
-   **그다음 맞닿는 지점들은 따로 배열을 만들어서 회전하기 전에 기록해 뒀다.**
-   **각각의 톱니바퀴의 회전방향도 배열을 만들어서 1(시계) , -1(반시계) , 0(회전 안 함)을 기록했다.**
-   **회전하기 직전에, 맞닿는 지점들의 대한 값과 회전방향을 초기화시켜 주면 된다.**
-   **각각의 톱니바퀴에 0번째 값을 검사해서 그에 따른 결과를 도출하면 됨.**

## **✔느낀 점**

-   **자료구조를 공부해야 하는 이유를 깨달았다.**
    -   **적절한 자료구조는 코드의 퀄리티를 높여준다.**  
        **만약 `deque`를 안 썼으면 매우 코드가 더러웠을 것 같음.. 아직 스터디원들 코드를 안 봐서 모르겠음!\]**
-   **문제를 잘 읽자..**
    -   **톱니바퀴는 무조건 회전하고 그 영향을 끼치는 것이었다!!!**
        -   **나는 맞닿는 부분이 같은 값이면 회전을 아예 안 해줬었다.**
-   **되도록이면 함수로 코드를 짜는 습관을 들이고 있는데, 아직 직관성이 조금 부족한 것 같다!**
-   **run 함수에서 저렇게 n을 특정하지 않고 함수를 짜고 싶었는데,, 내 창의성이 너무 모자라다.**