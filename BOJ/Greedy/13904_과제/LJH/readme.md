## **💡문제 해석**

**이 문제도 대표적인 greedy 탐욕 법 문제이다. 우선 입력받은 d와 w를 다음과 같은 방법으로 정렬했다.**

-   **이득이 큰 순서대로 정렬.**
-   **만약 이득이 같다면 과제 마감일이 큰 순서대로 정렬.**

**내가 처음에 접근한 방법은 마감일대로 딱딱 넣는다. (같은 마감일이 있다면 이득이 큰 것)**

**그럼 각 마감일마다 과제가 들어갈 것이다. 그러고 이제 선택받지 못한 과제들 중에서 선택한 과제들 중 가장 작은 것과 선택받지 못한 과제들 중에서 가장 큰 것을 바꿔주는 전략을 선택했지만, 어떤 이유에서인지 통과하지 못했다.**

**그래서 반례를 찾으려고 애를 써봤지만 찾지 못했다..**

**그래서 다시 생각해낸 방법이 마감일에서 가장 가깝게 과제를 할당하는 것이다.**

![img](https://user-images.githubusercontent.com/99114456/180640944-6c36d272-d3cb-4f93-af73-aa6b61395bb6.png)

**테스트 케이스를 입력 후 정렬하면 이러한 순서가 된다.**

**1.4,60에서 마감일을 4로 정하고, visit \[4\]가 true라면 넘어가고, false라면 다음과 같은 과정을 실행**

-   **sum에다가 60을 더하고 visit \[4\]를 true로 바꿔줌.** 

**2.2,50에서 마감일을 2로 정하고, visit \[2\]를 검사.**

-   **만약 True라면 넘어감.**
-   **False라면 sum에다가 50을 더하고 visit\[2\]를 true로 바꿔줌.**

**이런 식으로 진행하면 각 과제가 그 과제의 마감일과 최대한 가까운 날짜에 배정할 수 있으며, 애초에 처음부터 과제의 이득이 큰 순서대로 정렬했기 때문에, 최적의 해가 나올 것이다.**

## **👀구현**

**1\. 입력받은 자료들을 내가 원하는 대로 정렬하기**

![img](https://user-images.githubusercontent.com/99114456/180640946-91c394f2-fedb-4a80-be75-3ea8680d46da.png)

**2\. 나는 pair를 이용해서 deadline과 profit을 한꺼번에 저장했음.**

![img](https://user-images.githubusercontent.com/99114456/180640948-d16fe795-bc2a-418b-b8e4-9cf32793683e.png)

**3\. 마감일에 가깝게 과제를 배정하기.**

![img](https://user-images.githubusercontent.com/99114456/180640951-a56e903a-959a-4e68-b0ab-02121b862f10.png)


## **✔느낀 점**

-   **항상 내가 풀었던 알고리즘이 틀렸다고 인정하고 고치는 것은 쉽지가 않은 것 같다. 하지만 틀렸다고 느꼈을 때 처음부터 다시 짜는 과감함이 필요하다고 느꼈다.**
-   **알고리즘적으로는 어렵지 않았다. 그나마 조금 고심해서 생각한 것이 visit배열을 만든 것**