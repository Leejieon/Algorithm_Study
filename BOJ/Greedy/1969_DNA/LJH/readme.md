## **💡문제해석**

**굉장히 문제 해석하기 당황스러운 문제였다;;,,**

**처음에 난이도가 실버 5길래 굉장히 쉽게 풀릴 줄 알았는데 문제를 이해하는데서 좀 골이 아팠다.**

**여기서 등장하는 Hamming Distance라는 단어가 등장하는데 내 글에서는 간략하게 HD라고 설명하겠다.**

**HD가 최소가 되는 DNA가 무슨 말인지 한참을 걸려서 이해했다.**

**처음에 나는 주어진 문자열 중에서 가장 차이가 적은 문자열을 뽑았는데 답과 틀려서 당황했다,;;**

**문제가 요구하는 것은 입력에서 주어지는 N개의 DNA 서열과 비교해서 임의의 DNA를 만들고 그 DNA후보 중에서**

**가장 HD가 작은 염기서열을 내가 만드는 것이다.**

👀**HD가 작은 염기서열은 각 자릿수 별로 가장 많이 등장하는 알파벳으로 구성하면 된다. 그래야 주어진 DNA들과의 HD가 최소가 된다.**

---

## **구현**

#### **1\. 변수 선언**

![img](https://user-images.githubusercontent.com/99114456/180252080-49aa3d62-a4e9-4797-b995-b7d74430c97c.png)

-   n과 m은 n개의 DNA의 종류의 개수를 의미하고 m은 주어진 DNA에서 문자의 개수를 의미한다.
-   str은 DNA 서열을 저장하기 위한 vector
-   sum은 각 알파벳(염기서열)의 빈도수를 측정하기 위한 저장 vector
    -   빈도수가 같을 시 오름차순으로 정렬해야 하기 때문에 나는 편의상 알파벳이 작은 순서대로 index를 할당했다.
-   DNA vector는 이제 sum에 해당하는 index에 알파벳을 저장했다.
-   answer는 내가 최종적으로 구할 DNA를 출력

#### **2\. 빈도수 측정**

![img](https://user-images.githubusercontent.com/99114456/180252120-ccc581bc-7ba4-42fc-918f-0b98c2dd5a4a.png)

-   나는 n개의 DNA가 있을 때 각 자릿수 별로 알파벳의 빈도수를 측정했다.
-   각자가 대응되는 sum을 증가시켰다.

#### **3\. 알파벳 정하기**

![img](https://user-images.githubusercontent.com/99114456/180252153-afd83350-35b6-4086-87a1-b16a2f29da29.png)

-   최종적으로 HD가 작은 서열을 만들기 위해선 각 자리에서 빈도수가 높은 알파벳을 선정해서 넣어주면 된다.
-   여기서 만약 빈도수가 같을 시 자동적으로 내가 오름차순으로 정렬되게 만들었다.(위의 변수 선언에 자세한 설명이 있음.)

#### **4.HD의 값 계산**

![img](https://user-images.githubusercontent.com/99114456/180252180-70e50292-f0df-4845-a307-4eceba3477f0.png)

## **✔느낀 점**

-   **조금 더 간결하고 효율적으로 풀 수 있을 것 같지만, 처음 생각나는 대로 문제를 해결했다.**
-   **switch문을 사용해도 될 거 같고, pair를 사용해도 될거같고, 하지만 정말 무식하게 풀긴 했다.(다시 보니까 ㅎㅎ..)**
-   **문제만 잘 이해하면 쉽게 풀 수 있는 문제이다.**
-   **핵심은 HD가 최소인 서열을 만드는 것!**
-   **알고리즘적으로는 전혀 어려운 문제는 아니다.**