## **👀문제 해석**

-   **문제조건을 보면 시간제한과 메모리조건이 빡센걸 알 수 있다. \[진짜 빡세다\]**
-   **초기에 문제를 읽지 않고 n\*n으로 배열을 할당했는데 문제를 읽어보니 높이는 n이고 가로는 3칸으로 고정되어있었다.**
-   **메모리와 시간을 최대한 효울적으로 이용해서 푸는 것이 중요하다!**

## **🔎문제 풀이**

-   **다른사람들과 풀이가 다르다고 말할 수 있다.**  
    -   **다른사람들의 코드는 죄다 노가다로 비교하고, 만약 가로가 3이 아니라면 써먹을 수 없는 코드다.**
    -   **그렇게 짜는 코드는 굉장히 싫어하기 때문에 문제를 푸는데 골치가 좀 아팠다.**
-   **어쨋든 이 문제도 DP를 사용하는 문제라서 이전 값들을 저장할 공간이 필요한데**  
     **메모리제한때문에 잘 생각해서 짜야한다.**
-   **기본적으로 반복문은 (n-1)\*3번 돈다.**
-   **안쪽 반복문을 돌때마다 그 줄에서 최대값과 최소값을 구해준다.**
-   **그리고 안쪽 바깥문이 다 돌면 층을 바꿔줘서 직전층에서 저장된 값들을 이용해서 구해준다.**
    -   **왼쪽 위 값, 위 값, 오른쪽 위 값(갈 수 있는 전제하에)**  
        **각각을 현재 방문한 지역의 값에 더해서 최대값과 최소값을 구한다.**
    -   **이 최대값과 최소값을 저장해둬야한다. \[기존 배열을 바꾸지않고\]**
-   **바뀐값들을 저장하고, 층의 값들을 유지해야 하기에 1차원 배열을 4개 썼다.**
    -   **층의 값들을 유지하는 배열이 Max,Min / 바뀐값들을 저장하는 배열이 Big,Small이다.**
-   **안쪽 바깥문이 다돌면 Max와 Min값을 Big과 Small로 업데이트 시켜준다.**

![img](https://user-images.githubusercontent.com/99114456/212240203-419f630c-7b92-43f9-8e8e-d094f6ee08b1.png)


## **✔느낀점**
​
-   **내가 생각했던 문제보다 쉬워서 허망했다. \[가로칸을 3개로 고정시켜두다니..\]**
-   **노가다로 단순비교만 하면 되는문제다.**
-   **하지만 나는 그렇게 풀진 않았다는 점.**
    -   **다른사람 코드 진짜 못생김.**