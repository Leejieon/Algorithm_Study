## 🔎문제 풀이

> 문제를 읽어보시면 배낭 문제와 굉장히 유사한 점이 많다는 것을 DP문제를 풀어보셨다면 느꼈을 겁니다.  
> 배낭 문제는 물건 개수, 배낭 최대 무게가 있고,   
> 해당 문제는 앱 개수,  목표 메모리가 있습니다.  
> 우리는 최대무게와 목표 메모리를 향해 과정을 진행하면서 배낭은 이익을 최대로 , 앱은 비용을 최소로 하는 문제입니다.

따라서 해당 문제도 배낭과 유사하게 2차원 배열을 N \* M 배열로 선언하려고 했는데, 

input의 최대크기가 어마어마했습니다.

N은 최댓값이 100 -> 10^2, M은 10,000,000 -> 10^7 

그러면 이제 메모리의 크기는 4\*10^9 byte  이므로 128MB(128 \* 10^6)를 매우 매우 뛰어넘고도 남는 사이즈라서

아마 메모리 초과가 뜰 것입니다.

그렇다면 배열 크기에 대한 접근법을 다시 생각해봐야 합니다.

그래서 저는 배열의 크기를 N\*cost의 총합으로 했습니다.  그리고 배열에 들어가는 값은 앱의 메모리가 될 것입니다.

이렇게 된다면 메모리 초과를 신경 쓸 필요가 없어집니다.

dp \[N\]\[cost\] = memory

테스트케이스를 기준으로 예시를 들어서 설명하겠습니다. 

우선 저는 메모리가 크고, 비용이 작은 순서대로 앱을 정렬했습니다.

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 10/0 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 |
| 30/3 | 10 | 10 | 10 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 | 40 |
| 40/4 | 10 | 10 | 10 | 40 | 50 | 50 | 50 | 80 | 80 | 80 | 80 | 80 | 80 | 80 | 80 | 80 |
| 35/5 | 10 | 10 | 10 | 40 | 50 | 50 | 50 | 80 | 80 | 85 | 85 | 85 | 115 | 115 | 115 | 115 |
| 20/3 | 10 | 10 | 10 | 40 | 50 | 50 | 60 | 80 | 80 | 85 | 85 | 85 | 115 | 115 | 115 | 135 |

열은 몇 번째 앱인지를 뜻하고, 행은 비용을 뜻합니다.

만약 행이 해당 앱의 비용보다 작다면 이전상태의 값이 들어가게 됩니다.

행이 해당 앱의 비용보다 크거나 같다면 이전상태의 값 vs 이전상태에서 비용을 뺀 상태 + 해당 메모리값 중 최댓값이 들어가게 됩니다.

음 이게 말이 굉장히 어려운데 예시를 들면 무슨 느낌인지 아실 겁니다.


![](https://blog.kakaocdn.net/dn/dXMLWy/btr5Q3DWlPQ/ZNk8uy0B1wcHXkhfrsMxCK/img.png)

해당 번호가 메모리가 업데이트 일어난 상황입니다.

화살표가 아래로 내려간 경우는 앱을 종료시키지 않은 상황이고, 대각선으로 이동한 경우는 앱을 종료시킨 상황입니다.

1번의 경우 cost를 4까지 사용할 수 있어서 1번앱과 2번앱을 둘다 종료시키고 40의 메모리를 얻은 상황입니다.

6번의 경우 cost를 6까지 사용할수 있어서 1번 앱, 2번 앱, 6번 앱을 종료시키고, 60의 메모리를 얻은 상황입니다.

우리는 위 배열에서 목표 메모리인 M값을 넘고, 최소의 cost를 찾아야 하기에, 최소 cost인 6이라는 값을 얻을 수 있습니다.



## 😀느낀 점

-   메모리와 시간 복잡도는 항상 주의 깊게 보자.
    -   최악의 상황에서의 메모리를 계산해서 코드를 지웠다가 다시 짜는 상황은 다시는 없게 만들 ja...
-   다른 배낭문제와는 차별화된 점이 있어서 신선했다.
