## 문제 해석

> 알파벳이 될 수 있는 조건을 생각해주면 쉽게 풀 수 있는 문제입니다.  
> 하지만 여기까지는 모두가 생각하고, DP로 적용할려고 하니 저는 조금 어려웠습니다.

우선 알파벳은 'A'~'Z'까지 26개의 문자가 있습니다.

따라서 두 숫자를 합쳐서 읽을때 26보다 크다면, 그때는 알파벳으로 표현을 할 수가 없습니다.

경우의 수는 다음과 같습니다.

1.  숫자 두 개가 모두 0인 경우
    1.  해당 경우는 알파벳으로 해석이 불가능합니다. 따라서 0을 출력하고 프로그램을 종료해야 합니다.
2.  숫자 두 개를 합칠 수 있는 경우
    1.  합친 숫자가 10 이상 , 26 이하일 때 가능합니다.

즉 우리는 12가 있다면, "AB"로도 읽을 수 있고, "L"로도 읽을수 있습니다.

입력 첫 글자가 0이라면 암호가 될 수 없기에, 0을 출력하고 종료합니다.

DP배열은 1차원 배열로 선언했습니다.

DP \[X\]는 x번째 단어를 읽을 때 만들 수 있는 단어의 수입니다.

즉 DP \[3\]은 3번째 단어를 읽을 때 만들 수 있는 단어의 수입니다.

여기서 중요한 점은 DP \[0\]과 DP \[1\]은 무조건 1로 초기화해줘야 합니다.

왜냐하면 첫 글자를 읽을 수 있기 때문입니다.(0이 아니라는 조건이 있기 때문에 가능)

만약에 입력이 25114라면

DP \[2\]는 2번째 글자까지 읽을 때 만들 수 있는 경우의 수입니다.

우선 2번째 글자는 5라서 읽을 수 있습니다.

따라서 첫 번째까지 읽는 단어의 숫자를 그대로 들고 오면 됩니다.

즉 DP \[2\] = DP \[1\]이 됩니다.

그다음 앞에 숫자와 현재 숫자를 조합해서 경우의 수를 생각해 줍니다.

25가 됩니다. 25는 알파벳으로 'Y'를 만들 수 있습니다.

따라서 25를 읽기 전까지의 단계에서 만들 수 있는 단어의 개수 + 25까지 읽는 단계에서 만들 수 있는 단어의 개수가 됩니다.

음 말이 굉장히 어렵네요

즉 간단하게 , 

DP \[i\]=DP \[i-1\]   --> i번째 단어를 읽을 수 있는 경우 -> 즉 1~9 사이의 경우

DP \[i\]=DP \[i-2\]+DP \[i\]; -> 알파벳을 만들 수 있는 경우 -> 즉 10~26 사이 범위여야 합니다.

## 😀느낀 점

-   첫 글자가 0이면 exit(1) 같은 강제종료를 사용했는데, 런타임에러가 났다.
    -   초기에는 이유를 몰라서 허둥허둥했는데, exit(1) 대신 return 0을 하니까 해결됐다.
