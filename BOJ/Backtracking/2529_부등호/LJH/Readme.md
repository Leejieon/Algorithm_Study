## 🔎문제 해석

> 백트래킹 알고리즘은 진행하다가 막히면 이전 선택지에서 다른 경우를 선택하는 알고리즘이다.  
> 부등호문제와 백트래킹 알고리즘은 결이 비슷하다고 생각해서 백트래킹 알고리즘을 선택해서 풀었고, 문제 알고리즘 분류도 그러하다!  
> 백트래킹을 진행하면서 문제의 조건(모든 숫자는 딱 한번만, 부등호의 방향)을 생각하면서 최솟값과 최댓값을 구해주면 된다.

### 💡문제 풀이

-   기본적인 함수의 진행은 재귀함수로 진행했다.
    -   한칸씩 증가시키고, 문자열도 계속 이어 붙였다.
-   부등호의 방향에 따라 bool 값에 변화를 줬다. ">" -> true, "<" -> false
-   반복문을 0~9까지의 숫자를 검사했다.
-   만약 처음 넣는 경우라면 조건을 검사하지 않고, 문자열 뒤에 숫자를 이어 붙였다.
    -   여기서 방문처리를 한 후 -> 재귀함수 호출 -> (재귀함수가 만약에 빠져나온다면) 방문처리 초기화
-   만약 처음 넣는 경우가 아니라면, 부등호와 해당 숫자가 이미 사용되었는지에 대한 검사를 해줘야 한다.
    -   부등호의 방향이 > 라면, 지금 뽑으려는 숫자와, 이 전 숫자의 대소관계를 비교해서, 뽑으려는 숫자가 더 작아야 한다.
    -   부등호의 방향이 < 라면, 지금 뽑으려는 숫자와 , 이 전 숫자의 대소관계를 비교해서, 뽑으려는 숫자가 더 커야 한다.
-   만약 재귀호출이 n+1번 이루어졌다면, 그때 문자열을 숫자로 바꿔서 최솟값과 최댓값을 각각 갱신해 주면 된다.

### ❌주의할 점

> #### **나는 int형으로 stoi를 사용했는데 부등호가 9개일 때 int의 범위를 벗어나기에 long을 사용해야 한다!**

## 😀느낀 점

-   문자열 -> 정수, 정수 -> 문자열로 계속 변환해서 코드를 작성해서 엄청 헷갈리고 보는 사람도 헷갈릴 거라고 생각한다.
    -   더 좋은 방법이 있을 거 같은데 문자열 다루는 건 정말 익숙하지가 않다.
