## **🔎문제 해석**

**항상 이런 탐색 문제는 BFS로 하는지 DFS로 하는지 초반에 가닥을 잡는 것이 중요하다.**

**문제를 읽어보면 항상 답이 나온다.**

**문제에서 최대로 진행할 수 있는 칸을 구하라는 말이 있다. 즉 이말은 DFS로 푸는 것이 효율적이라고 할 수 있다.**

**어떠한 경로로 갔다가 막히면 그 출발점에서 다시 다른 경로를 선택해야 하기에 모든 방향을 탐색하는 것보단 하나의 선택지로 쭉 탐색한 뒤 실패하면 다시 제자리로 돌아가서 다른 경로를 탐색하는 것이 맞다고 생각했다.**

**(실제로 맞는지는 차차 확인하면 될거같은..~)**

## **📃풀이 방식**

1.  **크게 사용한 배열은 3가지이다.**
    1.  **graph : 입력한 문자를 저장하는 배열**
    2.  **visit : 방문여부를 check**
    3.  **alph : 해당 알파벳을 밟았는지를 check**   
        1.  **대문자 A는 아스키코드 값이 65라서 A를 배열의 인덱스 0으로 잡고 65를 뺀 index 값으로 넣어줫음.**
2.  **출발점을 푸쉬하고 DFS 실행**
3.  **DFS**
    1.  **내가 지나온 칸의 길이를 항상 갱신 (DFS깊이와 , 이미 저장된 값)**
    2.  **stack에 top에 있는 좌표를 추출하고 pop하고, 해당 좌표를 방문처리, 알파벳 방문 처리**
    3.  **상하좌우로 탐색**
        1.  **이동한 좌표가 배열을 벗어난다면 pass**
        2.  **만약 이동한 좌표에 해당하는 알파벳을 밟았거나, 이동한 좌표를 이미 방문했다면 pass**
    4.  **탐색 후에 적절한 좌표라면 알파벳과 방문을 처리하고 stack에 push하고 DFS를 재귀호출**
    5.  **만약 재귀호출이 끝나면 그 차례에 방문했던 좌표를 방문처리를 제거한다. (알파벳,방문처리)**
4.  **DFS가 끝나면 result(최대로 진행한 칸수)를 출력한다.**

## **✔느낀 점**

-   **우선 이 문제 굉장히 빨리 풀어서 뿌듯했지만, 그냥 골드 4의 난이도라고 하기에는 조금 애매했던 것 같다.**
-   **dfs의 구조와 알파벳의 여부를 체크하는 방법만 알면 빨리 풀 수 있는 문제인 것 같다.**
-   **나는 10분 만에 풀었음!!**
