## **💻문제 해석**
---
​
**입력 테스트 케이스에 대한 고정관념을 버려야 한다.**
​
**나도 이러한 고정관념 덕분에 고생을 꽤나 했다. 처음에는 이 문제가 왜 BFS,DFS를 사용하는 문제지?라는 생각을 했다.**
​
**초기 나는 입력 테스트 케이스처럼 각 좌표가 거리가 먼순으로 차례대로 주어질줄 알았는데, 그것이 아니었다.**
​
**그리고 모든 편의점을 거칠 필요가 없다.**
​
**이러한 고정관념을 벗어나니 이 문제는 bfs로 푸는 것이 가장 효율적인 방법이라는 것을 알았다.**
​
#### **💡초기 풀이방식** 
---
​
**각 지점에서 다음 편의점까지 갈 수있는지에 대한 여부를 검사하고, 마지막 편의점까지 성공적으로 도착했다면, 도착 지점까지 갈 수 있는지에 대한 여부를 검사해서 sad와 happy를 출력했다.**
​

**\-> 잘못된 풀이 방식.**
​
**이유 :**
​

**1) 입력받은 편의점 좌표들이 오름차순으로 정렬된 좌표가 아니다. \[순서대로 탐색한다면 틀린 결과가 나옴\]**

​
**2) 편의점들의 좌표보다 도착점의 좌표가 가까운 경우의 수가 있다. \[모든 편의점을 방문할 이유가 없음**
​
#### **💡수정한 풀이 방식**
---
1.  **편의점과 도착점의 좌표를 모두 vector에 넣음.**
2.  **queue에 초기 좌표를 넣고, 갈 수 있는 모든 지점에 좌표를 queue에 넣음.**
    -   **이 때 갈수있다는 기준은 초기좌표와 이동하려고 하는 좌표의 거리차가 1000이하면 이동가능**
    -   **만약 이동할 수 있다고 판단되면 queue에 넣고, vector에 해당 좌표를 지워줌.\[방문을 했으니까!\]**
3.  **초기 좌표를 queue에 front로 갱신해줌.**
    -   **1,2번 반복**
4.  **queue를 계속 탐색하는데 만약 queue에 좌표가 도착지점과 일치하다면 happy를 출력**
5.  **queue를 끝까지 탐색해도 도착지점까지 가지 못한다면 sad를 출력**


**느낀점**
---
-   **문제를 정확하게 읽고 테스트 케이스를 생각해야 한다.**
-   **이상한 데서 핀트가 꽂혀서 문제를 지맘대로 해석하지 않기..**
-   **그라가스.**
