## **🔎문제 해석**

---

**외부 공기와 내부 공기를 분리시키는 작업이 중요한 문제이다.** 

**내부 공기는 치즈에 영향을 주지 않지만, 외부 공기는 치즈에 영향을 주기 때문이다.**

**공기를 구분 한뒤 그 외부 공기와 맞닿은 지역을 녹이는 작업을 계속하면 된다.**

**나는 BFS를 사용해서 풀었다.**

#### **💡초기 풀이 방식**

1.  **입력받은 배열중 0은 공기, 1을 치즈라고 생각했다.**
    1.  **치즈에 해당하는 부분은 queue에 푸쉬했다.**
2.  **그다음에 bfs를 돌렸다.**

####   **🛑문제점**

1.  **내부 공기와 외부 공기를 분리를 시키지 않아서 문제가 풀리지 않았다.**

#### **💡수정 풀이 방식**

1.  **외부 공기와 내부 공기를 구분했다.**
    1.  **내부 공기는 치즈에 영향을 주지 않기 때문이다.**
2.  **배열을 입력받는 과정에서 만약 그 위치가 치즈라면\[값이 1이라면\] 그 좌표에 대한 visit값을 0으로 세팅해주고, queue에 넣어주고, 치즈의 조각을  +1 해줌.**
    1.  **초기 치즈의 조각도 계산해줄 필요가 있다. \[아예 녹일 수 없는 상황이라면 그 초기의 치즈 개수가 최종 치즈의 개수이기 때문이다.\] -> 이것은 문제를 풀다 보면 이해할 수 있을 것이다. 마지막 테케가 아예 녹이지 못하게 되는 경우라서 꼭 이 작업을 해줘야 한다!**
3.  **visit배열을 새로 만들었다. \[초기 값은 내부 공기에 해당하는 값을 세팅해줌\]**
    1.  **세팅 값 : 2=내부 공기, 1 = 외부 공기, 0 = 치즈**
4.  **내부 공기를 뽑는 방법은 (0,0)에서 출발해서 0으로만 이동을 쭉쭉한다. \[BFS 사용\]**
5.  **외부 공기와 인접하는 치즈들을 녹이는 작업을 시작한다.**
    1.  **기본적으로는 BFS 작업.**
    2.  **상하좌우로 이동한 뒤 적절한 이동이고, 근처에 좌표 중 하나라도 공기가 있다면 치즈를 녹임**
6.  **녹인 뒤 시간을 +1 해준다.**
7.  **사용한 queue를 초기화해주고, visit 배열도 다시 초기화해준다.**
8.  **그리고 다시 2,3,4,5,6,7 작업을 반복한다.**
9.  **그러다가 만약 모든 배열에 값이 0이라면 \[치즈가 다 녹았다면\] 빠져나와서 결과값을 출력함.**

## **✔느낀 점**
-   **신선한 문제였다.**
-   **100%에서 틀리길래 뭔가 했는데 모든 배열이 1111111111111111111 즉 치즈로 채워진 경우에는 내가 생각을 안 해줘서 100%에서 틀린 거 같다.**
-   **BFS는 이제 좀 할만할지도..?**
