## 🔎문제 해석

> 문제가 길고 그림이 복잡해보이지만, BFS 알고리즘을 사용해서 최솟값을 구하는 문제입니다.  
> 이러한 유형은 반복된 유형을 풀어보는것만이 방법입니다.

우선 상위티어 BFS/DFS 문제는 3차원 배열을 사용해서 값을 추가로 하나 더 기록하는 방법을 사용하는 문제가 아주 많습니다.

예를 들어 방향을 저장하던가, 방향에 대한 값을 저장하던가, 이러한 식으로 3차원 배열을 사용해서 이전 방향에 대한 값을 저장해야 합니다.

지금도 저희는 도착지점까지의 최소 거울의 개수를 필요로 하기에, 3차원 배열에 각 진행방향 별로 거울의 개수를 저장해 줍니다.

예를 들어서

(X, Y) -> (A, B)로 이동을 하는 시점에서, 만약 방향을 바꾼다면, 거울을 하나 추가해줘야 합니다.

따라서 (A, B, 바뀐 방향) = (X, Y, 기존방향)+1이 답일 것입니다.

(X, Y) -> (A, B)로 이동을 하는 시점에서 , 만약 방향을 바꾸지 않는다면, 거울의 개수는 변동이 없습니다.

따라서 (A, B, 기존방향) = (X, Y, 기존방향) 일 것입니다.

그리고 저희는 항상 거울을 최소로 필요로 하기에, 방문할 때마다 비교를 해줘서 거울을 업데이트해줘야 하며 

도착지점에 도착 시 최솟값을 저장합니다.

## 😀느낀 점
​
-   상위 티어 BFS 문제를 풀어보면 알 수 있듯이, 단순히 탐색하는 거에 지치지 않고, 고차원 배열을 사용해서 값을 기록하는 방식의 풀이법이 많은 것 같다.
-   BFS 문제는 반복하면 눈에 익히고, 코드도 손에 익는 것 같다.
