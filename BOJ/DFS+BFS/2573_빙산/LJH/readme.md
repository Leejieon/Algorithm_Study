## **💡문제해석**

**문제를 읽으면 DFS를 사용해야 하는지 BFS를 사용해야 하는지 판단할 줄 알아야 한다.**

**문제를 잘 읽어보면 구하려는 바가 빙하가 2덩어리 이상으로 분리되는 최소의 년을 구하는 것이다.** 

**최솟값?! -> BFS라고 생각하면 된다. \[확신을 못하지만 거의 다 그렇다..ㅎ\]**

## **✋주의해야 할 점**

**큐에 빙산의 위치를 넣는다. 그러고 하나씩 큐에서 pop 하면서 바람을 적용시킨다. 하지만 모든 얼음이 동시에 바람에 영향을 받아야 하는데 이런 방식으로 하나하나씩 하면 적절하지 않은 답이 나온다. 이 점을 잘 해결해야 한다.**

---

## **👀구현**

#### **1\. 변수 선언**

![img](https://user-images.githubusercontent.com/99114456/182563854-485f39ef-f2e6-4576-b8af-0d230922adbe.png)

-   **ice는 빙산과 바다를 입력하는 배열**
-   **visit는 해당 년초에 이 자리가 빙산인지, 바다인지 체크하기 위함.**
-   **fact는 빙산의 개수를 계산할때 사용**
-   **자세한 설명들은 아래 구현에서 설명할예정이담.**

#### **2\. 방향 선언**

![img](https://user-images.githubusercontent.com/99114456/182563863-de942944-737a-4122-bf6e-2a1f148d3769.png)

-   **문제 설명에서 바람은 왼쪽, 오른쪽, 아래, 위에서 불어오는 것을 알 수 있다. \[오른쪽, 왼쪽, 아래, 위\]**

#### **3\. 빙산 넣기**

![img](https://user-images.githubusercontent.com/99114456/182563864-6cc1c8ec-5440-4a26-a5e9-65603f725cab.png)

-   **num이 0이 아니라면 빙산이라는 뜻이므로 큐에 좌표를 넣어주고, 빙산이라는 사실을 visit배열로 체크해준다.**

#### **4.BFS함수**

![img](https://user-images.githubusercontent.com/99114456/182563867-6a1428a1-1ea9-4457-9aa4-365eeaf4db22.png)

-   **size는 바람 불기 전의 빙하의 개수, Size는 바람을 맞는 빙하의 수이다.**
    -   **Size와 size가 같다면 1년이 지난 것이다.**
-   **큐에서 pop을 하고 해당 좌표를 4가지의 방향으로 움직임.**
    -   **만약 잘못된 좌표라면 continue.**
-   **움직인 후에 그 좌표가 바다이고, 지금 내 기준 좌표에 빙산이 아직 남아있고, 움직인 좌표가 처음부터 바다인 곳이라면**
    -   **기준 좌표에 빙산을 한층 깎아준다.**
-   **4가지 방향으로 이동한 뒤 만약 빙산이 사라지지 않고 남아있다면 다시 큐에 좌표를 푸시한다.**

![img](https://user-images.githubusercontent.com/99114456/182563870-8456a7b6-d958-4e9d-a004-14adc03b1ecd.png)

-   **Size와 size가 같아질 때 연도가 바뀐다는 것을 위에서 설명했다.**
-   **그럼 년도를 더해주고, size와 Size를 다시 최신화해준다.**
-   **이제 빙산의 개수를 체크해줄 것이다.**
    -   **행렬 전체를 탐색하는데 만약 바다라면 visit값을 0으로 바꿔준다.**
    -   **여기서 fact라는 배열이 등장하는데 fact는 내가 빙산의 개수를 계산할 때 해당 땅을 밟았는지의 여부를 체크하는 것이다. \[자세한 것은 checkice함수 내에서 설명할 예정이다\]**
-   **만약 빙산의 개수\[Icenum\]가 2 이상이라면 그때의 연도가 답이고 출력하면 된다.**
-   **만약 빙산의 개수가 2개가 안 나왔다면 fact배열을 0으로 초기화해주고, 빙산의 개수를 다시 0으로 바꿔준다.**

![img](https://user-images.githubusercontent.com/99114456/182563875-400b2434-103f-475a-9405-bcf3eb15f74d.png)

-   **fact배열은 모두 0으로 초기화되어있다.**
-   **빙하의 개수는 상, 하, 좌, 우로 연결되어있다면 하나로 계산한다.**
-   **row, col을 기준으로 4가지 방향을 탐색하는데 움직인 좌표가 빙하고, 아직 밟지 않은 곳이라면 재귀 문으로 이동한 좌표를 다시 실행한다.**
-   **하나의 지점을 잡고 움직일 수 있는 모든 좌표를 방문한 뒤, 방문처리를 해주고를 반복하면 빙산의 개수를 구할 수 있을 것이다.**

---

## **✔느낀 점**

-   **원래 있던 빙하가 녹아서 다른 빙하에 영향을 주는 사실을 인지를 하는 것이 중요했고, 그것을 코드화 하는 것이 문제의 관건이다.**
    -   **조금 더 간결하게 하고 싶었지만, 배열을 여러 개 사용하는 안 좋은 습관을 사용한 것 같다.**
-   **빙하의 개수를 계산하는 함수는 잘 짠 것 같다.**
-   **문제는 BFS를 바로 찾아냈다면 쉽게 풀 수 있는 문제이다.**