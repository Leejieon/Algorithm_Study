
## **💡문제해석**

> **처음 문제를 읽어보고 이해하는데 조금 걸렸다. 그래서 높이 정보를 어디 주는 거지?라고 계속 보고 있었는데 모든 높이에 대해서 최댓값을 구하는 것이었다;;**  
> **자세한 문제 설명은 코드를 보면서 할 예정이다.**

---

## **구현**

### **⚡변수 선언**

![img](https://user-images.githubusercontent.com/99114456/183115035-3712cc80-7547-4571-9bd1-40cbeb52795f.png)

-   **n은 입력값, Big은 행렬 중에서 가장 큰 값을 저장함. \[나중에 while문 돌릴 때 끝나는 지점을 계산하기 위함\], answer은 출력 값**
-   **grpah는 입력 행렬이고 visit는 방문 배열이다.**
-   **q는 row, col을 넣어줄 queue이고, x와 y는 각각 네 가지 방향을 뜻하는 배열이다.**

### **⚡행렬 입력**

![img](https://user-images.githubusercontent.com/99114456/183115043-d163539a-8c73-4128-b6f3-2a0c11df53b1.png)

-   **행렬을 입력받고 값을 하나하나 비교해서 최고층의 높이를 계산함.**

### **⚡해당 높이에서 영역의 개수를 계산하기.**

![img](https://user-images.githubusercontent.com/99114456/183115047-58107de8-f7e7-43b7-9ecd-2068809aac32.png)

-   **while문은 최고층의 높이까지 진행해준다. 그 이후로는 어차피 모든 영역이 잠기게 될 것이다.**
-   **행렬을 탐색하면서 해당 높이가 high보다 작거나 같다면 visit \[i\]\[j\]를 0으로 초기화해줌. \[잠겼다는 뜻\], 높이가 high보다 크다면 큐에 푸시함.**
-   **bfs() 함수 실행**
-   **answer 중에서 최댓값을 block에 넣어줌.**
-   **high를 한 칸 증가시키고 answer를 0으로 초기화한 후 visit배열을 다시 초기화함.**

### **⚡BFS함수**

![img](https://user-images.githubusercontent.com/99114456/183115051-39065c79-b874-408a-9364-aa5a54dd8caa.png)

-   **큐가 빌 때까지 반복하는데 front에 있는 원소를 추출하고 만약 해당 row와 col을 이미 방문한 상태\[즉 visit \[Row\]\[Col\]이 1이면\] 넘어가고, 방문한 상태가 아니라면 checkrain을 실행 후 영역의 개수를 하나 더해줌.**
-   **checkrain은 내가 움직일 수 있는 좌표로 이동해주면서 가능한 영역을 탐색하는 함수이다.**
-   **적절한 영역인지 따지고, 방문할 수 있는 곳인지를 검사한다. 만약 그곳이 방문한 곳이라면 재귀를 탈출하고 다른 방향으로 탐색을 시작한다.**

## **✔느낀 점**

> **이 문제를 풀고 안 풀고는 중요하지가 않다. 얼마나 효율적으로 푸는 것이 중요한데. 나는 그러지 못한 것 같다.**  
> **더 좋은 방법이 있었을 거 같은데,,, 조금 더 깔끔하게 짜고 싶다..!**

**\[문제 자체는 쉬운 편이다.\]**
