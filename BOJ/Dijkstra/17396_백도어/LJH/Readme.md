## **🔎문제 해석**

**처음에는 아무 생각 없이 인접 행렬로 풀었는데 메모리 초과라는 결과가 나왔다.. 당황했었는데 사실 당연하게도**

**분기점과 분기점을 잇는 길의 수가 굉장히 많기 때문에 행렬로 구현한다면 엄청난 크기의 메모리를 잡아먹는다는 사실을 잊고 있었다. 그래서 허겁지겁 다른 방법인 인접 리스트로 풀었다. 인접 리스트라는 방식이 손에 잘 익지 않아서 굉장히 애를 먹었었고, 최댓값의 limit 값을 정하는 과정에서 굉장히 시행착오가 많았다,,ㅎㅎ(문제를 잘 읽어보자!)**

---

## **🛑주의할 점**

**넥서스를 잇는 길은 양방향이며, 넥서스가 위치한 N-1번째 분기점에는 와드가 있는데, 그것을 0으로 초기화하는 것이 중요하다.**

---

## **⚡구현**

![img](https://user-images.githubusercontent.com/99114456/184618865-a555b51b-5a3d-4b99-b85c-fcac51ba2f9f.png)

1.  **와드의 여부를 입력받고 넥서스의 위치에 있는 와드는 0으로 초기화해준다.**
2.  **양방향으로 분기점을 입력받는다.**

![img](https://user-images.githubusercontent.com/99114456/184618868-4964a72d-4075-4f85-9a77-c82dd78003a9.png)

1.  **PQ에는 오름차순으로 정렬되게끔 선언해줬다. pair의 first기준으로 오름차순으로 정렬했다.**
2.  **PQ의 top에 있는 원소를 뽑아주고, 거리 테이블과의 거리를 비교해서 더 현재 뽑은 원소의 거리가 길다면 탐색할 필요가 없다.**
3.  **for문을 통해서 현재 갈 수 있는 모든 지역을 탐색한다.**
    1.  **현재 가고자 하는 지역에 와드가 있다면 continue**
    2.  **와드에 걸리지 않았다면 다음 갈옷에 대한 거리와, 그 지역을 pair next에 넣어주고**
    3.  **next의 거리가 거리 테이블보다 작다면 거리 테이블을 최신화해주고 PQ에 푸시해준다.**

![img](https://user-images.githubusercontent.com/99114456/184618872-e0ad90ab-c51b-4aac-80e6-efd35939309e.png)

1.  **모든 과정이 끝났는데 만약 넥서스까지의 거리를 의미하는 d \[n-1\]이 INF라면 경로가 없다는 뜻이다.**
2.  **INF가 아니라면 그때의 값을 출력함.**

## **✔느낀 점**
​
-   **인접 리스트로 짜는 방법도 연습해야 할 것 같다.**
-   **우선순위 큐와 pair를 묶어서 쓰니까 너무 어려웠다. <-- 이 부분도 이론에 대한 정리가 필요한 것 같다.**
-   **그리고 항상 문제에 경우의 수에 대한 최댓값을 계산해서 INF값을 넣어줘야겠다.**
-   **생각보다 어려웠다..!**
