## **🔎문제 해석**
**기본적으로 문제는 BFS를 사용해서 풀었다. 하지만 이동하는 기준은 이제 최소한의 벽을 부수는 이동을 기준 잡고 이동했다.**
​
-   **변수 선언**
    -   **graph : 입력받는 행렬 저장**
    -   **visit : 해당 좌표로 이동하는데 부수는 벽의 개수 (초기화는 INT\_MAX)**
        -   **왜냐하면 최소의 벽 개수를 계속 업데이트 해야하기에 가장 큰 값을 넣어줬다.**
    -   **x,y : 이동하는 방향을 저장.**
    -   **queue : 좌표를 저장하기 위해서 사용**
-   **1,1에서 출발하고 1,1은 벽이 없기에 visit\[1\]\[1\]=0으로 초기화했다.**
-   **BFS실행**
    -   **queue에 있는 좌표를 추출하고 그 좌표를 기준으로 상하좌우 이동했다.**
        -   **적절하지 않는 이동이면 continue해줌.**
    -   **만약 이동한 좌표에 벽이 있을때**
        -   **이동한 좌표로 가는 벽의 개수를 비교해야함.**
            -   **벽이 있기에 기준 좌표 + 1, 즉 벽의 개수를 더해줘야함.** 
            -   **이동한 좌표로 가는 벽의 개수 VS 기준 좌표 + 1** 
            -   **이동좌표로 가는 벽의 개수가 더 크다면 기준 좌표 +1 로 초기화해주고 queue에 넣어줌.**
            -   **이동좌표로 가는 벽의 개수가 더 작다면 아무일도 일어나지 않음.** 
                -   **최소 경로가 아니기에 무시해주면 됨.**
    -   **만약 이동한 좌표에 벽이 없다면**
        -   **이동한 좌표로 가는 벽의 개수를 비교해야함.**
            -   **벽이 없기에 기준좌표와 저장된 이동한 좌표로 가는 벽의 개수를 비교해야함.**
            -   **이동한 좌표로 가는 벽의 개수 vs 기준좌표**
            -   **이동좌표로 가는 벽의 개수가 더 크다면 기준좌표 값으로 업데이트해주고, queue에 넣어줌.**
            -   **이동좌표로 가는 벽의 개수가 더 작다면 아무일도 일어나지않음.**
                -   **최소 경로가 아니라는 뜻임.**
-   **BFS를 탈출하면 도착지까지의 최소 벽의 개수가 visit\[m\]\[n\]에 저장됨.**


## **✔느낀점**
-   **입력하는 과정에서 입력 예제가 m,n이 바껴있어서 ㅈㄴ짜증났다.**
-   **원래는 우선순위 큐를 사용했는데, 굳이 그럴 필요가 없었던것 같다.**
-   **좌표를 뽑는 과정에서 내가 그전에 걸러주면 상관 없었으니 우선순위 큐 사용은 필수는 아닌듯?**
