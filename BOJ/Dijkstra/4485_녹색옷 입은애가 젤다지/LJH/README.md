## **🔎문제 풀이**
-   **도착지점까지 최소한의 값을 방문하는 문제이다.**
-   **나는 BFS를 이용해서 풀었다. 초기에는 priority\_queue를 이용해서 풀었다.**
    -   **pq에는 이때까지 축적된 값과 행렬 좌표를 넣었다.**
    -   **pq는 축적된 값의 오름차순으로 정렬된다.**
    -   **그래서 가장 최적의 루트를 방문하게끔 만들었다.**
-   **잘못된 풀이방식..?**
    -   **메모리 초과 발생**
    -   **내 생각보다 pq가 메모리를 많이 잡아먹은것 같다.**

## **💡수정된 풀이 방식**
-   **기존 풀이 방식과 거의 유사하지만 pq를 사용하지 않고, q를 사용, 이동한 좌표의 최소값\[visit배열\]을 갱신해줬다.**
-   **변수선언**
    -   **graph : 입력 행렬**
    -   **visit : 루피를 저장하는 배열**
    -   **q에는 {X,Y}좌표가 들어감.**
-   **visit 배열을 INT\_MAX로 초기화한뒤\[최소값을 저장하기 위함\] 출발점에 해당하는 visit값을 출발점에 해당하는 루피 값으로 업데이트 해줬다.**
    -   **visit\[0\]\[0\]= graph\[0\]\[0\]**
-   **BFS진행**
    -   **q가 완전히 empty될때까지 진행**
    -   **상하좌우로 탐색**
        -   **적절한 이동이 아니라면 pass**
        -   **적절한 이동이라면 visit 배열을 비교**
            -   **이동하려는 좌표 (tempx,tempy) / 기존 좌표 (fx,fy)**
            -   **visit\[tempx\]\[tempy\]값 (그 좌표까지 이동하는데 축적된 루피값) vs visit\[fx\]\[fy\] (기존 좌표까지 이동하는데 축적된 루피값) + graph\[tempx\]\[tempy\] (이동 좌표에 저장된 루피값) 을 비교한다.**
                -   **visit\[tempx\]\[tempy\] > visit\[fx\]\[fy\] + graph\[tempx\]\[tempy\] 라면 값을 갱신해주고 q에 넣어준다.**
                -   **위의 경우가 아니라면 q에 갱신할 필요가 없다.**
-   **BFS가 끝나면 visit\[n-1\]\[n-1\]에는 (n-1,n-1)까지 가는데 저장된 최소한의 루피값이 들어가게 된다.**
  ## **✔느낀점**
-   **pq가 생각보다 메모리를 많이 잡아먹는다는 사실을 알게 되었다.** 
-   **내가 원하는 기준으로 정렬해주는 pq를 사용하고 싶지만, 메모리 초과로 그냥 수작업으로 계속 갱신해줬다.**
-   **출력 형식도 맞추기 까다로웠다. 공백 하나 차이로 출력 오류라닝..**
-   **만약 50%에서 틀린다면 예시로 주어지는 테스트 케이스만 정답처리된 것이니 아예 다시 짜기를..**
-   **녹색 옷 입 은애가 젤다인 줄 알았는데 아녔구나 ㅎㅋ**
