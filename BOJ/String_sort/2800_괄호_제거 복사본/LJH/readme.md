## **📕문제해석**
​
**괄호의 대응되는 방식을 알아야 함.**
​
-   **괄호의 종류는 왼쪽 괄호, 오른쪽 괄호가 있다.--> ( , )**
-   **대응되는 순서는 가장 나중에 등장한 왼쪽 괄호와 가장 먼저 등장한 오른쪽 괄호가 대응된다.**
-   **이때의 index를 pair를 사용해서 넣어준다.**
​
![img](https://user-images.githubusercontent.com/99114456/179949582-259d7f4c-9445-4a68-b8ec-1848136e5799.png)
​
-   **여기서 pop\_back()을 해주는 이유는 왼쪽 괄호와 오른쪽 괄호가 서로 짝을 찾았기 때문에 다음 왼쪽 괄호에 대응되는 오른쪽 괄호를 찾아주기 위해서 빼준다.**
​
**visit 배열은 str배열과 동일시되는데 해당 index에 str을 넣어줄지 말지를 결정하는 배열임.**
​
#### **재귀를 통해서 모든 조합을 탐색해줌.**
​
-   **pair의 first는 왼쪽 괄호의 index, second는 오른쪽 괄호의 index이다.**
-   **해당 괄호를 포함시키고 싶지 않을 때 true로 초기화하고 재귀 함수를 호출해서 문자열에 넣어준다.**

![img](https://user-images.githubusercontent.com/99114456/179949632-45f1aeeb-55f3-4100-8ddf-738d4e72452c.png)​
#### **문자열 생성**
​
-   **visit \[j\]가 true인 부분은 포함하지 않게 문자열을 생성해주고 괄호를 제거했는데, 만약 문자열이 같은 경우가 있을 수 있기 때문에 map의 개념을 사용해서 중복되지 않고, 자동으로 오름차순 정렬되게 넣어준다.**
​
![img](https://user-images.githubusercontent.com/99114456/179949717-5111f4ac-8279-4f9c-8f8c-6e932fbc5ae6.png)

---​
## **✔느낀 점**
​
-   **처음에 괄호의 위치를 저장했지만, pair의 개념을 사용하지 않고 각각의 vector를 만들어서 따로 저장했다.**
-   **괄호의 위치를 저장하는 것은 어렵지 않았지만, 경우의 수를 찾는 것이 어렵지 않았다.**
    -   **처음에는 순열의 조합 개념을 사용해서 풀려고 했지만, 구현하기가 어려웠다.**
    -   **그래서 모든 경우의 수를 탐색할 수 있는 dfs를 통해서 구현했다.**
-   **처음에 중복된 문자열이 있다는 것을 생각 못했는데 (((1)))은 어떤 괄호를 처음에 제거하더라도 ((1))이 되기 때문에 중복이 발생한다는 것을 깨닫고 map을 사용했다.**
-   **dfs는 자주 쓰이니까 계속 훈련하는 것이 좋겠다.**